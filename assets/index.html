<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Temperature Monitor</title>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <!-- Day.js and plugins -->
        <script src="https://unpkg.com/dayjs/dayjs.min.js"></script>
        <script src="https://unpkg.com/dayjs/plugin/customParseFormat.js"></script>
        <script src="https://unpkg.com/dayjs/plugin/duration.js"></script>
        <script src="https://unpkg.com/dayjs/plugin/isSameOrAfter.js"></script>
        <script>
            dayjs.extend(window.dayjs_plugin_customParseFormat);
            dayjs.extend(window.dayjs_plugin_duration);
            dayjs.extend(window.dayjs_plugin_isSameOrAfter);
        </script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 50%, #0f0f0f 100%);
                color: #e0e0e0;
                min-height: 100vh;
                line-height: 1.6;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }

            .header {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 30px;
                margin-bottom: 30px;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            }

            .header h1 {
                font-size: 2.5rem;
                font-weight: 300;
                margin-bottom: 10px;
                background: linear-gradient(45deg, #4fc3f7, #29b6f6, #03a9f4);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 15px;
            }

            .header .subtitle {
                font-size: 1.1rem;
                color: #888;
                font-weight: 300;
            }

            .dashboard {
                display: grid;
                grid-template-columns: 2fr 1fr;
                gap: 30px;
                margin-bottom: 30px;
            }

            .chart-container {
                background: rgba(255, 255, 255, 0.03);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 30px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                position: relative;
            }

            .chart-container h2 {
                font-size: 1.3rem;
                font-weight: 400;
                margin-bottom: 20px;
                color: #fff;
                text-align: center;
            }

            .chart-wrapper {
                position: relative;
                height: 300px;
                width: 100%;
            }

            .temperature-overlay {
                position: absolute;
                top: 8px;
                left: 60px;
                z-index: 10;
                font-size: 2.5rem;
                font-weight: 300;
                color: rgba(79, 195, 247, 0.9);
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            .temperature-overlay .temp-value {
                display: inline;
                line-height: 1;
            }

            .temperature-overlay .temp-unit {
                font-size: 1.2rem;
                opacity: 0.8;
                margin-left: 2px;
            }

            .info-panel {
                background: rgba(255, 255, 255, 0.03);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 30px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            }

            .info-panel h2 {
                font-size: 1.3rem;
                font-weight: 400;
                margin-bottom: 20px;
                color: #fff;
                border-bottom: 2px solid rgba(79, 195, 247, 0.3);
                padding-bottom: 10px;
            }

            .info-grid {
                display: grid;
                gap: 15px;
            }

            .info-item {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                padding: 15px;
                transition: all 0.3s ease;
            }

            .info-item:hover {
                background: rgba(255, 255, 255, 0.08);
                transform: translateY(-2px);
            }

            .info-item .label {
                font-size: 0.85rem;
                color: #888;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-bottom: 5px;
            }

            .info-item .value {
                font-size: 1.1rem;
                color: #fff;
                font-weight: 500;
            }

            .status-indicator {
                display: inline-block;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: #4caf50;
                margin-right: 8px;
                animation: pulse 2s infinite;
            }

            .status-indicator.warning {
                background: #ff9800;
            }

            .status-indicator.error {
                background: #f44336;
            }

            @keyframes pulse {
                0% { opacity: 1; }
                50% { opacity: 0.5; }
                100% { opacity: 1; }
            }

            .footer {
                background: rgba(255, 255, 255, 0.03);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 20px;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            }

            .footer p {
                color: #888;
                font-size: 0.9rem;
            }

            @media (max-width: 768px) {
                .dashboard {
                    grid-template-columns: 1fr;
                }
                
                .header h1 {
                    font-size: 2rem;
                    flex-direction: column;
                    gap: 10px;
                }
                
                .container {
                    padding: 15px;
                }
            }
        </style>
    </head>

    <body>
        <div class="container">
            <header class="header">
                <h1>
                    <img src="thermo.svg" alt="Thermometer">
                    Temperature Monitor
                </h1>
                <p class="subtitle">Temperature Monitor with Smart Gap Detection</p>
            </header>

            <div class="dashboard">
                <div class="chart-container">
                    <div class="temperature-overlay">
                        <span class="temp-value" id="currentTemp">--.-</span><span class="temp-unit">Â°C</span>
                    </div>
                    <h2>Parent's Bedroom</h2>
                    <div class="chart-wrapper">
                        <canvas id="temperatureChart"></canvas>
                    </div>
                </div>

                <div class="info-panel">
                    <h2>System Information</h2>
                    <div class="info-grid">
                        <div class="info-item">
                            <div class="label">Data Status</div>
                            <div class="value">
                                <span class="status-indicator" id="dataStatusIndicator"></span>
                                <span id="dataStatusText">Initializing...</span>
                            </div>
                        </div>
                        <div class="info-item">
                            <div class="label">Data Points</div>
                            <div class="value" id="dataPointCount">0</div>
                        </div>
                        <div class="info-item">
                            <div class="label">Current Time</div>
                            <div class="value" id="time">{time}</div>
                        </div>
                        <div class="info-item">
                            <div class="label">System Uptime</div>
                            <div class="value" id="uptime">{uptime}</div>
                        </div>
                    </div>
                </div>
            </div>

            <footer class="footer">
                <p>Data updates every minute â€¢ Chart displays 24-hour rolling window â€¢ Automatic gap detection and recovery</p>
            </footer>
        </div>
        
        <script>
            console.log("=== TEMPERATURE MONITOR INITIALIZATION ===");
            console.log("System startup at:", new Date().toLocaleString());
            
            const ctx = document.getElementById('temperatureChart');
            const DISPLAY_DATA_POINTS = 289; // 0â€“288
            const INTERVAL_MINUTES = 5;
            const EXPECTED_DATA_INTERVAL_MINUTES = 5;

            // Store data points with their timestamps for proper repositioning
            let dataPoints = new Map(); // timestamp -> {value, dayjs_obj}
            let lastHistoricalFetch = null; // Prevent rapid repeated fetches

            // Full data contiguity check
            function checkFullDataContiguity() {
                if (dataPoints.size < 2) {
                    return { 
                        isContiguous: false, 
                        needsHistory: dataPoints.size === 0, // Only fetch if we have no data at all
                        gaps: [],
                        totalDataPoints: dataPoints.size
                    };
                }
                
                // Get all data points sorted by time
                const sortedPoints = Array.from(dataPoints.entries())
                    .map(([timestamp, data]) => ({
                        timestamp,
                        time: data.dayjs_obj,
                        value: data.value
                    }))
                    .sort((a, b) => a.time.diff(b.time));
                
                const gaps = [];
                const maxAllowedGap = EXPECTED_DATA_INTERVAL_MINUTES * 1.8; // 9 minutes tolerance
                
                // Check each consecutive pair
                for (let i = 1; i < sortedPoints.length; i++) {
                    const gap = sortedPoints[i].time.diff(sortedPoints[i-1].time, 'minutes');
                    if (gap > maxAllowedGap) {
                        gaps.push({
                            start: sortedPoints[i-1].time.format('HH:mm'),
                            end: sortedPoints[i].time.format('HH:mm'),
                            duration: gap,
                            startTime: sortedPoints[i-1].time,
                            endTime: sortedPoints[i].time
                        });
                    }
                }
                
                return {
                    isContiguous: gaps.length === 0,
                    needsHistory: gaps.length > 0,
                    gaps: gaps,
                    totalDataPoints: dataPoints.size,
                    dataRange: sortedPoints.length > 0 ? {
                        oldest: sortedPoints[0].time.format('HH:mm'),
                        newest: sortedPoints[sortedPoints.length - 1].time.format('HH:mm')
                    } : null
                };
            }

            // Update status display
            function updateDataStatus() {
                const analysis = checkFullDataContiguity();
                
                let statusClass = 'good';
                let statusText = 'Data Complete';
                
                if (analysis.totalDataPoints === 0) {
                    statusClass = 'error';
                    statusText = 'No Data';
                } else if (analysis.gaps.length > 0) {
                    statusClass = 'warning';
                    statusText = `${analysis.gaps.length} Gap(s) Detected`;
                } else if (analysis.totalDataPoints < 50) { // Less than ~4 hours of data
                    statusClass = 'warning';
                    statusText = 'Limited Data';
                }
                
                // Update UI elements
                const statusIndicator = document.getElementById('dataStatusIndicator');
                const statusTextElement = document.getElementById('dataStatusText');
                const dataPointCountElement = document.getElementById('dataPointCount');
                
                if (statusIndicator) {
                    statusIndicator.className = `status-indicator ${statusClass === 'good' ? '' : statusClass}`;
                }
                
                if (statusTextElement) {
                    statusTextElement.textContent = statusText;
                }
                
                if (dataPointCountElement) {
                    dataPointCountElement.textContent = analysis.totalDataPoints.toString();
                }
                
                console.log("Data status:", statusText, "- Points:", analysis.totalDataPoints, "- Gaps:", analysis.gaps.length);
                if (analysis.gaps.length > 0) {
                    console.log("Gaps found:", analysis.gaps);
                }
                
                return analysis;
            }

            // Get current rolling window boundaries (consistent across all functions)
            function getCurrentWindow() {
                const now = dayjs();
                const nextFullHour = dayjs(now).add(1, 'hour').startOf('hour');
                const windowStart = nextFullHour.subtract(24, 'hours');
                const windowEnd = nextFullHour;
                return { windowStart, windowEnd, nextFullHour };
            }

            // Rolling window positioning - data moves with time
            function getDataIndexForTime(timeString) {
                console.log("=== CALCULATING DATA INDEX ===");
                const now = dayjs();
                const today = now.format('YYYY-MM-DD');
                let dataTime = dayjs(`${today} ${timeString}`, 'YYYY-MM-DD HH:mm');
                
                if (dataTime.isAfter(now)) {
                    dataTime = dataTime.subtract(1, 'day');
                }
                
                const { windowStart } = getCurrentWindow();
                const minutesFromWindowStart = dataTime.diff(windowStart, 'minute', true);
                const index = Math.floor(minutesFromWindowStart / INTERVAL_MINUTES);
                
                console.log("Data time:", dataTime.format('YYYY-MM-DD HH:mm'));
                console.log("Window start:", windowStart.format('YYYY-MM-DD HH:mm'));
                console.log("Minutes from window start:", minutesFromWindowStart);
                console.log("Calculated index:", index);
                
                return {
                    index: Math.max(0, Math.min(index, 288)),
                    dataTime: dataTime,
                    windowStart: windowStart
                };
            }

            // Generate complete rolling labels
            function generateRollingLabels() {
                console.log("=== GENERATING ROLLING LABELS ===");
                const labels = [];
                const { windowStart } = getCurrentWindow();
                
                for (let i = 0; i < DISPLAY_DATA_POINTS; i++) {
                    labels.push(windowStart.add(i * INTERVAL_MINUTES, 'minute').format('HH:mm'));
                }
                
                console.log("Window start:", windowStart.format('YYYY-MM-DD HH:mm'));
                console.log("Generated labels - first 5:", labels.slice(0, 5));
                console.log("Generated labels - last 5:", labels.slice(-5));
                
                return labels;
            }

            // Rebuild data array from stored data points based on current time window
            function rebuildDataArray() {
                console.log("=== REBUILDING DATA ARRAY ===");
                const { windowStart, windowEnd } = getCurrentWindow();
                
                const newData = new Array(DISPLAY_DATA_POINTS).fill(null);
                
                // Filter and reposition data points that fall within the current window
                for (const [timestamp, dataPoint] of dataPoints.entries()) {
                    if (dataPoint.dayjs_obj.isSameOrAfter(windowStart) && dataPoint.dayjs_obj.isBefore(windowEnd)) {
                        const minutesFromWindowStart = dataPoint.dayjs_obj.diff(windowStart, 'minute', true);
                        const index = Math.floor(minutesFromWindowStart / INTERVAL_MINUTES);
                        
                        if (index >= 0 && index < DISPLAY_DATA_POINTS) {
                            newData[index] = dataPoint.value;
                            console.log(`Repositioned data: ${timestamp} -> index ${index}, value ${dataPoint.value}`);
                        }
                    } else {
                        // Remove data points that are now outside the window
                        console.log(`Removing old data point: ${timestamp}`);
                        dataPoints.delete(timestamp);
                    }
                }
                
                console.log(`Active data points: ${dataPoints.size}`);
                return newData;
            }

            // === Chart Initialization ===
            let rollingLabels = generateRollingLabels(); 
            const cc = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: rollingLabels,
                    datasets: [{
                        label: 'Temperature',
                        data: new Array(DISPLAY_DATA_POINTS).fill(null),
                        borderColor: 'rgba(79, 195, 247, 1)',
                        backgroundColor: 'rgba(79, 195, 247, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        pointBackgroundColor: 'rgba(79, 195, 247, 0.8)',
                        pointBorderColor: 'rgba(79, 195, 247, 1)',
                        borderWidth: 2,
                        spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: false },
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: (context) => context.index % 36 === 0 
                                    ? 'rgba(255, 255, 255, 0.1)' 
                                    : 'transparent'
                            },
                            ticks: {
                                autoSkip: false,
                                callback: (value, index) => index % 36 === 0 ? rollingLabels[index] : '',
                                minRotation: 45,
                                maxRotation: 45,
                                color: '#888'
                            }
                        },
                        y: {
                            beginAtZero: false,
                            min: 12,
                            max: 28,
                            ticks: { 
                                color: '#888',
                                callback: (value) => value + 'Â°C'
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    }
                }
            });

            let lastUpdatedHour = dayjs().hour();

            function updateLabelsToCurrentTime() {
                const now = dayjs();
                const currentHour = now.hour();
                
                console.log("=== LABEL UPDATE CHECK ===", now.format('HH:mm:ss'));
                
                if (currentHour !== lastUpdatedHour) {
                    console.log("ðŸ• Hour changed:", lastUpdatedHour, "â†’", currentHour);
                    lastUpdatedHour = currentHour;
                    
                    // Generate new labels
                    const newRollingLabels = generateRollingLabels();
                    
                    // Rebuild data array with proper positioning
                    const newDataArray = rebuildDataArray();
                    
                    // Update chart
                    rollingLabels = newRollingLabels;
                    cc.data.labels = rollingLabels;
                    cc.data.datasets[0].data = newDataArray;
                    
                    cc.update('none');
                    console.log("âœ… Rolling window update complete with data repositioning");
                }
            }

            function ProcessData(item) {
                console.log("=== PROCESSING NEW DATA ===", item);
                try {
                    const newData = JSON.parse(item);
                    const result = getDataIndexForTime(newData.time);
                    const dataIndex = result.index;
                    
                    if (dataIndex >= 0 && dataIndex < DISPLAY_DATA_POINTS) {
                        // Check for invalid temperature values
                        if (newData.temperature === "None" || newData.temperature === null || newData.temperature === undefined || newData.temperature === "") {
                            console.log("âš  Temperature value is invalid:", newData.temperature, "- skipping data point");
                            return;
                        }

                        const newValue = parseFloat(newData.temperature);
                        const newTimestamp = result.dataTime.format('YYYY-MM-DD HH:mm');
                        const newDataTime = result.dataTime;
                        
                        // Check if we already have data for this 5-minute window
                        // Look for existing data points that map to the same chart index
                        let existingTimestamp = null;
                        let existingDataTime = null;
                        
                        for (const [timestamp, dataPoint] of dataPoints.entries()) {
                            const existingResult = getDataIndexForTime(dataPoint.dayjs_obj.format('HH:mm'));
                            if (existingResult.index === dataIndex) {
                                existingTimestamp = timestamp;
                                existingDataTime = dataPoint.dayjs_obj;
                                break;
                            }
                        }
                        
                        // If we found existing data for this window, keep only the more recent one
                        if (existingTimestamp && existingDataTime) {
                            if (newDataTime.isAfter(existingDataTime)) {
                                // New data is more recent, remove the old one
                                dataPoints.delete(existingTimestamp);
                                console.log(`Replaced older data at ${existingTimestamp} with newer data at ${newTimestamp}`);
                            } else {
                                // Existing data is more recent, ignore new data
                                console.log(`Ignoring older data ${newTimestamp}, keeping existing ${existingTimestamp}`);
                                return;
                            }
                        }
                        
                        // Store the new data point
                        dataPoints.set(newTimestamp, {
                            value: newValue,
                            dayjs_obj: newDataTime
                        });
                        
                        // Update chart data
                        cc.data.datasets[0].data[dataIndex] = newValue;

                        // Update the large temperature overlay
                        const tempElement = document.getElementById('currentTemp');
                        if (tempElement) {
                            tempElement.textContent = newValue.toFixed(1);
                        }

                        cc.update('none');
                        cc.setActiveElements([]);
                        cc.tooltip.setActiveElements([], {x: 0, y: 0});
                        console.log("âœ… Data updated at index", dataIndex, ":", newValue, "timestamp:", newTimestamp);
                        
                        // Check data contiguity after adding new data
                        const contiguityCheck = checkFullDataContiguity();
                        updateDataStatus();
                        
                        // Only fetch historical data if we have gaps and haven't fetched recently
                        const now = dayjs();
                        const shouldFetch = contiguityCheck.needsHistory && 
                                          (!lastHistoricalFetch || now.diff(lastHistoricalFetch, 'minutes') > 2);
                        
                        if (shouldFetch) {
                            console.log("ðŸ” Data gaps detected, fetching historical data");
                            console.log("Gaps:", contiguityCheck.gaps);
                            lastHistoricalFetch = now;
                            fetchHistoricalData();
                        }
                        
                    } else {
                        console.log("âš  INDEX OUT OF RANGE:", dataIndex);
                    }
                } catch (error) {
                    console.error("âš  Error processing data:", error);
                }
            }

            // Fetch and process historical data from server
            async function fetchHistoricalData() {
                console.log("=== FETCHING HISTORICAL DATA ===");
                try {
                    const response = await fetch("/api/history");
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const responseText = await response.text();
                    console.log("Raw response:", responseText);
                    
                    let historicalData;
                    try {
                        historicalData = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error("JSON parse error:", parseError);
                        console.error("Response was:", responseText);
                        return;
                    }
                    
                    if (!Array.isArray(historicalData)) {
                        console.error("Expected array but got:", typeof historicalData, historicalData);
                        return;
                    }
                    
                    console.log("Received historical data points:", historicalData.length);
                    
                    if (historicalData.length === 0) {
                        console.log("No historical data available from server");
                        return;
                    }
                    
                    // Process historical data (merge with existing, don't replace)
                    let processedCount = 0;
                    let oldestTime = null;
                    let newestTime = null;
                    
                    for (const dataPoint of historicalData) {
                        try {
                            const dateStr = dataPoint.date || dayjs().format('YYYY-MM-DD');
                            const dataTime = dayjs(`${dateStr} ${dataPoint.time}`, 'YYYY-MM-DD HH:mm');
                            const timestamp = dataTime.format('YYYY-MM-DD HH:mm');
                            const temperature = parseFloat(dataPoint.temperature);
                            
                            if (!isNaN(temperature) && !dataPoints.has(timestamp)) {
                                dataPoints.set(timestamp, {
                                    value: temperature,
                                    dayjs_obj: dataTime
                                });
                                processedCount++;
                                
                                if (!oldestTime || dataTime.isBefore(oldestTime)) {
                                    oldestTime = dataTime;
                                }
                                if (!newestTime || dataTime.isAfter(newestTime)) {
                                    newestTime = dataTime;
                                }
                            }
                        } catch (error) {
                            console.warn("Error processing historical data point:", dataPoint, error);
                        }
                    }
                    
                    console.log(`Successfully processed ${processedCount} new historical data points`);
                    if (oldestTime && newestTime) {
                        console.log(`Data range: ${oldestTime.format('YYYY-MM-DD HH:mm')} to ${newestTime.format('YYYY-MM-DD HH:mm')}`);
                        console.log(`Coverage: ${newestTime.diff(oldestTime, 'hour', true).toFixed(1)} hours`);
                    }
                    
                    // Rebuild the chart with all data
                    const newDataArray = rebuildDataArray();
                    cc.data.datasets[0].data = newDataArray;
                    cc.update('none');
                    
                    // Update status
                    updateDataStatus();
                    
                    console.log("âœ… Historical data loaded and chart updated");
                    
                } catch (err) {
                    console.error("âš  Failed to fetch historical data:", err);
                }
            }

            // Enhanced polling with contiguity check
            async function pollData() {
                console.log("=== NETWORK POLLING ===", new Date().toLocaleTimeString());
                try {
                    const response = await fetch("/tempdata");
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const text = await response.text();
                    ProcessData(text);
                } catch (err) {
                    console.error("âš  TempData request failed:", err);
                }
            }

            // Status updates
            async function updateStatus() {
                try {
                    const response = await fetch("/api/status");
                    if (!response.ok) throw new Error(`HTTP ${response.status}`); 
                        const data = await response.json();
                        // Update time and uptime fields
                        ['time', 'uptime'].forEach(key => {
                            const element = document.getElementById(key);
                            if (element && data[key]) {
                                element.textContent = data[key];
                            }
                        });
                } catch (err) {
                    console.error("âš  Status request failed:", err);
                }
            }

            // === Scheduling system for label updates ===
            function scheduleLabelUpdate() {
                const now = new Date();
                const msUntilNextHour = (60 - now.getMinutes()) * 60000
                                      - now.getSeconds() * 1000
                                      - now.getMilliseconds();

                console.log("Next label update scheduled in", (msUntilNextHour / 1000).toFixed(1), "seconds");

                setTimeout(() => {
                    updateLabelsToCurrentTime();
                    scheduleLabelUpdate(); // reschedule for the following hour
                }, msUntilNextHour);
            }

            // Initialize the application
            async function initializeApp() {
                console.log("=== INITIALIZING APPLICATION ===");
                
                // Update labels first
                updateLabelsToCurrentTime();
                
                // Poll immediately for initial data
                await pollData();
                
                console.log("=== INITIALIZATION COMPLETE ===");
            }

            // Run initialization after a short delay
            setTimeout(initializeApp, 1000);

            // Kick off hourly scheduling
            scheduleLabelUpdate();

            // Enhanced tab wake-up detection
            document.addEventListener("visibilitychange", async () => {
                if (document.visibilityState === "visible") {
                    console.log("ðŸ”„ Tab became visible â€“ checking data and polling immediately");
                    updateLabelsToCurrentTime();
                    
                    // Poll immediately when tab becomes visible
                    await pollData();
                }
            });

            // Polling for new temperature data (every minute)
            setInterval(pollData, 60000);

            // Update time every second
            setInterval(updateStatus, 1000);
            
            // Update data status every 10 seconds (also updates when new data arrives)
            setInterval(updateDataStatus, 10000);
        </script>

        <script src="default.js"></script>
    </body>
</html>
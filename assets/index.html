<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Temperature Monitor</title>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <!-- Day.js and plugins -->
        <script src="https://unpkg.com/dayjs/dayjs.min.js"></script>
        <script src="https://unpkg.com/dayjs/plugin/customParseFormat.js"></script>
        <script src="https://unpkg.com/dayjs/plugin/duration.js"></script>
        <script src="https://unpkg.com/dayjs/plugin/isSameOrAfter.js"></script>
        <script>
            dayjs.extend(window.dayjs_plugin_customParseFormat);
            dayjs.extend(window.dayjs_plugin_duration);
            dayjs.extend(window.dayjs_plugin_isSameOrAfter);
        </script>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 50%, #0f0f0f 100%);
                color: #e0e0e0;
                min-height: 100vh;
                line-height: 1.6;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }

            .header {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 30px;
                margin-bottom: 30px;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            }

            .header h1 {
                font-size: 2.5rem;
                font-weight: 300;
                margin-bottom: 10px;
                background: linear-gradient(45deg, #4fc3f7, #29b6f6, #03a9f4);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 15px;
            }

            .header .subtitle {
                font-size: 1.1rem;
                color: #888;
                font-weight: 300;
            }

            .dashboard {
                display: grid;
                grid-template-columns: 2fr 1fr;
                gap: 30px;
                margin-bottom: 30px;
            }

            .chart-container {
                background: rgba(255, 255, 255, 0.03);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 30px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                position: relative;
            }

            .chart-container h2 {
                font-size: 1.3rem;
                font-weight: 400;
                margin-bottom: 20px;
                color: #fff;
                text-align: center;
            }

            .chart-wrapper {
                position: relative;
                height: 300px;
                width: 100%;
            }

            .temperature-overlay {
                position: absolute;
                top: 8px;
                left: 60px;
                z-index: 10;
                font-size: 2.5rem;
                font-weight: 300;
                color: rgba(79, 195, 247, 0.9);
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            .temperature-overlay .temp-value {
                display: inline;
                line-height: 1;
            }

            .temperature-overlay .temp-unit {
                font-size: 1.2rem;
                opacity: 0.8;
                margin-left: 2px;
            }

            .info-panel {
                background: rgba(255, 255, 255, 0.03);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 30px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            }

            .info-panel h2 {
                font-size: 1.3rem;
                font-weight: 400;
                margin-bottom: 20px;
                color: #fff;
                border-bottom: 2px solid rgba(79, 195, 247, 0.3);
                padding-bottom: 10px;
            }

            .info-grid {
                display: grid;
                gap: 15px;
            }

            .info-item {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                padding: 15px;
                transition: all 0.3s ease;
            }

            .info-item:hover {
                background: rgba(255, 255, 255, 0.08);
                transform: translateY(-2px);
            }

            .info-item .label {
                font-size: 0.85rem;
                color: #888;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-bottom: 5px;
            }

            .info-item .value {
                font-size: 1.1rem;
                color: #fff;
                font-weight: 500;
            }

            .status-indicator {
                display: inline-block;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: #4caf50;
                margin-right: 8px;
                animation: pulse 2s infinite;
            }

            .status-indicator.warning {
                background: #ff9800;
            }

            .status-indicator.error {
                background: #f44336;
            }

            @keyframes pulse {
                0% { opacity: 1; }
                50% { opacity: 0.5; }
                100% { opacity: 1; }
            }

            .footer {
                background: rgba(255, 255, 255, 0.03);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                padding: 20px;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            }

            .footer p {
                color: #888;
                font-size: 0.9rem;
            }

            @media (max-width: 768px) {
                .dashboard {
                    grid-template-columns: 1fr;
                }
                
                .header h1 {
                    font-size: 2rem;
                    flex-direction: column;
                    gap: 10px;
                }
                
                .container {
                    padding: 15px;
                }
            }
        </style>
    </head>

    <body>
        <div class="container">
            <header class="header">
                <h1>
                    <img src="thermo.svg" alt="Thermometer">
                    Temperature Monitor
                </h1>
                <p class="subtitle">Simple Server-Authoritative Data Sync</p>
            </header>

            <div class="dashboard">
                <div class="chart-container">
                    <div class="temperature-overlay">
                        <span class="temp-value" id="currentTemp">--.-</span><span class="temp-unit">°C</span>
                    </div>
                    <h2>Parent's Bedroom</h2>
                    <div class="chart-wrapper">
                        <canvas id="temperatureChart"></canvas>
                    </div>
                </div>

                <div class="info-panel">
                    <h2>System Information</h2>
                    <div class="info-grid">
                        <div class="info-item">
                            <div class="label">Data Status</div>
                            <div class="value">
                                <span class="status-indicator" id="dataStatusIndicator"></span>
                                <span id="dataStatusText">Initializing...</span>
                            </div>
                        </div>
                        <div class="info-item">
                            <div class="label">Local / Server</div>
                            <div class="value"><span id="localDataCount">0</span> / <span id="serverDataCount">0</span></div>
                        </div>
                        <div class="info-item">
                            <div class="label">Current Time</div>
                            <div class="value" id="time">{time}</div>
                        </div>
                        <div class="info-item">
                            <div class="label">System Uptime</div>
                            <div class="value" id="uptime">{uptime}</div>
                        </div>
                    </div>
                </div>
            </div>

            <footer class="footer">
                <p>Data updates every minute • Chart displays 24-hour rolling window • Server-authoritative sync</p>
            </footer>
        </div>
        
        <script>
            console.log("=== TEMPERATURE MONITOR INITIALIZATION ===");
            console.log("System startup at:", new Date().toLocaleString());
            
            const ctx = document.getElementById('temperatureChart');
            const DISPLAY_DATA_POINTS = 289; // 0–288
            const INTERVAL_MINUTES = 5;

            // Store data points with their timestamps for proper repositioning
            let dataPoints = new Map(); // timestamp -> {value, dayjs_obj}
            let serverDataCount = 0; // Track server's total data points
            let lastHistoricalFetch = null; // Prevent rapid repeated fetches

            // Update status display
            function updateDataStatus() {
                let statusClass = 'good';
                let statusText = 'Data Synced';
                
                const localCount = dataPoints.size;
                const serverCount = serverDataCount;
                
                if (localCount === 0 && serverCount === 0) {
                    statusClass = 'warning';
                    statusText = 'No Data';
                } else if (localCount < serverCount) {
                    statusClass = 'warning';
                    statusText = 'Syncing...';
                } else if (localCount === serverCount && serverCount > 0) {
                    statusClass = 'good';
                    statusText = 'Complete';
                }
                
                // Update UI elements
                const statusIndicator = document.getElementById('dataStatusIndicator');
                const statusTextElement = document.getElementById('dataStatusText');
                const localDataCountElement = document.getElementById('localDataCount');
                const serverDataCountElement = document.getElementById('serverDataCount');
                
                if (statusIndicator) {
                    statusIndicator.className = `status-indicator ${statusClass === 'good' ? '' : statusClass}`;
                }
                
                if (statusTextElement) {
                    statusTextElement.textContent = statusText;
                }
                
                if (localDataCountElement) {
                    localDataCountElement.textContent = localCount.toString();
                }
                
                if (serverDataCountElement) {
                    serverDataCountElement.textContent = serverCount.toString();
                }
                
                console.log(`Data status: Local ${localCount}, Server ${serverCount} - ${statusText}`);
            }

            // Get current rolling window boundaries
            function getCurrentWindow() {
                const now = dayjs();
                const nextFullHour = dayjs(now).add(1, 'hour').startOf('hour');
                const windowStart = nextFullHour.subtract(24, 'hours');
                const windowEnd = nextFullHour;
                return { windowStart, windowEnd, nextFullHour };
            }

            // Rolling window positioning - data moves with time
            function getDataIndexForTime(timeString) {
                const now = dayjs();
                const today = now.format('YYYY-MM-DD');
                let dataTime = dayjs(`${today} ${timeString}`, 'YYYY-MM-DD HH:mm');
                
                if (dataTime.isAfter(now)) {
                    dataTime = dataTime.subtract(1, 'day');
                }
                
                const { windowStart } = getCurrentWindow();
                const minutesFromWindowStart = dataTime.diff(windowStart, 'minute', true);
                const index = Math.floor(minutesFromWindowStart / INTERVAL_MINUTES);
                
                return {
                    index: Math.max(0, Math.min(index, 288)),
                    dataTime: dataTime,
                    windowStart: windowStart
                };
            }

            // Generate complete rolling labels
            function generateRollingLabels() {
                const labels = [];
                const { windowStart } = getCurrentWindow();
                
                for (let i = 0; i < DISPLAY_DATA_POINTS; i++) {
                    labels.push(windowStart.add(i * INTERVAL_MINUTES, 'minute').format('HH:mm'));
                }
                
                return labels;
            }

            // Rebuild data array from stored data points based on current time window
            function rebuildDataArray() {
                const { windowStart, windowEnd } = getCurrentWindow();
                const newData = new Array(DISPLAY_DATA_POINTS).fill(null);
                
                // Filter and reposition data points that fall within the current window
                for (const [timestamp, dataPoint] of dataPoints.entries()) {
                    if (dataPoint.dayjs_obj.isSameOrAfter(windowStart) && dataPoint.dayjs_obj.isBefore(windowEnd)) {
                        const minutesFromWindowStart = dataPoint.dayjs_obj.diff(windowStart, 'minute', true);
                        const index = Math.floor(minutesFromWindowStart / INTERVAL_MINUTES);
                        
                        if (index >= 0 && index < DISPLAY_DATA_POINTS) {
                            newData[index] = dataPoint.value;
                        }
                    } else {
                        // Remove data points that are now outside the window
                        dataPoints.delete(timestamp);
                    }
                }
                
                return newData;
            }

            // === Chart Initialization ===
            let rollingLabels = generateRollingLabels(); 
            const cc = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: rollingLabels,
                    datasets: [{
                        label: 'Temperature',
                        data: new Array(DISPLAY_DATA_POINTS).fill(null),
                        borderColor: 'rgba(79, 195, 247, 1)',
                        backgroundColor: 'rgba(79, 195, 247, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 2,
                        pointBackgroundColor: 'rgba(79, 195, 247, 0.8)',
                        pointBorderColor: 'rgba(79, 195, 247, 1)',
                        borderWidth: 2,
                        spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: false },
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: (context) => context.index % 36 === 0 
                                    ? 'rgba(255, 255, 255, 0.1)' 
                                    : 'transparent'
                            },
                            ticks: {
                                autoSkip: false,
                                callback: (value, index) => index % 36 === 0 ? rollingLabels[index] : '',
                                minRotation: 45,
                                maxRotation: 45,
                                color: '#888'
                            }
                        },
                        y: {
                            beginAtZero: false,
                            min: 12,
                            max: 28,
                            ticks: { 
                                color: '#888',
                                callback: (value) => value + '°C'
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    }
                }
            });

            let lastUpdatedHour = dayjs().hour();

            function updateLabelsToCurrentTime() {
                const now = dayjs();
                const currentHour = now.hour();
                
                if (currentHour !== lastUpdatedHour) {
                    lastUpdatedHour = currentHour;
                    
                    // Generate new labels and rebuild data array
                    const newRollingLabels = generateRollingLabels();
                    const newDataArray = rebuildDataArray();
                    
                    // Update chart
                    rollingLabels = newRollingLabels;
                    cc.data.labels = rollingLabels;
                    cc.data.datasets[0].data = newDataArray;
                    
                    cc.update('none');
                    console.log("Rolling window update complete");
                }
            }

            function ProcessData(item) {
                console.log("=== PROCESSING NEW DATA ===", item);
                try {
                    const newData = JSON.parse(item);
                    
                    // Skip invalid temperature values during sensor initialization
                    if (newData.temperature === "None" || newData.temperature === null || newData.temperature === undefined || newData.temperature === "") {
                        console.log("Temperature value is invalid:", newData.temperature, "- skipping");
                        
                        // Still update server count if provided
                        if (newData.totalDataPoints !== undefined) {
                            serverDataCount = newData.totalDataPoints;
                            updateDataStatus();
                        }
                        return;
                    }
                    
                    const result = getDataIndexForTime(newData.time);
                    const dataIndex = result.index;
                    
                    if (dataIndex >= 0 && dataIndex < DISPLAY_DATA_POINTS) {
                        const newValue = parseFloat(newData.temperature);
                        
                        if (isNaN(newValue)) {
                            console.error("Temperature value is NaN after parsing, skipping");
                            return;
                        }
                        
                        const newTimestamp = result.dataTime.format('YYYY-MM-DD HH:mm');
                        const newDataTime = result.dataTime;
                        
                        // Check if we already have data for this 5-minute window (keep most recent)
                        let existingTimestamp = null;
                        let existingDataTime = null;
                        
                        for (const [timestamp, dataPoint] of dataPoints.entries()) {
                            const existingResult = getDataIndexForTime(dataPoint.dayjs_obj.format('HH:mm'));
                            if (existingResult.index === dataIndex) {
                                existingTimestamp = timestamp;
                                existingDataTime = dataPoint.dayjs_obj;
                                break;
                            }
                        }
                        
                        // Keep only the most recent data point for this 5-minute window
                        if (existingTimestamp && existingDataTime) {
                            if (newDataTime.isAfter(existingDataTime)) {
                                dataPoints.delete(existingTimestamp);
                                console.log(`Replaced older data at ${existingTimestamp} with newer data at ${newTimestamp}`);
                            } else {
                                console.log(`Ignoring older data ${newTimestamp}, keeping existing ${existingTimestamp}`);
                                return;
                            }
                        }
                        
                        // Store the new data point
                        dataPoints.set(newTimestamp, {
                            value: newValue,
                            dayjs_obj: newDataTime
                        });
                        
                        // Update chart data
                        cc.data.datasets[0].data[dataIndex] = newValue;

                        // Update the temperature display
                        const tempElement = document.getElementById('currentTemp');
                        if (tempElement) {
                            tempElement.textContent = newValue.toFixed(1);
                        }

                        cc.update('none');
                        console.log(`Data updated at index ${dataIndex}: ${newValue}°C`);
                        
                    } else {
                        console.log("INDEX OUT OF RANGE:", dataIndex);
                    }
                    
                    // Server-authoritative sync check
                    if (newData.totalDataPoints !== undefined) {
                        serverDataCount = newData.totalDataPoints;
                        
                        // Simple comparison: if server has more data points, fetch history
                        const localCount = dataPoints.size;
                        if (serverDataCount > localCount) {
                            const now = dayjs();
                            const shouldFetch = !lastHistoricalFetch || now.diff(lastHistoricalFetch, 'minutes') > 2;
                            
                            if (shouldFetch) {
                                console.log(`Server has ${serverDataCount} data points, we have ${localCount} - fetching history`);
                                lastHistoricalFetch = now;
                                fetchHistoricalData();
                            }
                        }
                    }
                    
                    updateDataStatus();
                    
                } catch (error) {
                    console.error("Error processing data:", error);
                }
            }

            // Fetch and process historical data from server
            async function fetchHistoricalData() {
                console.log("=== FETCHING HISTORICAL DATA ===");
                try {
                    const response = await fetch("/api/history");
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const responseText = await response.text();
                    let historicalData;
                    try {
                        historicalData = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error("JSON parse error:", parseError);
                        return;
                    }
                    
                    if (!Array.isArray(historicalData)) {
                        console.error("Expected array but got:", typeof historicalData);
                        return;
                    }
                    
                    console.log("Received historical data points:", historicalData.length);
                    
                    if (historicalData.length === 0) {
                        console.log("No historical data available");
                        return;
                    }
                    
                    // Process historical data (merge, don't replace)
                    let processedCount = 0;
                    
                    for (const dataPoint of historicalData) {
                        try {
                            // Skip invalid temperature values
                            if (dataPoint.temperature === "None" || dataPoint.temperature === null || dataPoint.temperature === undefined) {
                                continue;
                            }
                            
                            const dateStr = dataPoint.date || dayjs().format('YYYY-MM-DD');
                            const dataTime = dayjs(`${dateStr} ${dataPoint.time}`, 'YYYY-MM-DD HH:mm');
                            const timestamp = dataTime.format('YYYY-MM-DD HH:mm');
                            const temperature = parseFloat(dataPoint.temperature);
                            
                            if (!isNaN(temperature) && !dataPoints.has(timestamp)) {
                                dataPoints.set(timestamp, {
                                    value: temperature,
                                    dayjs_obj: dataTime
                                });
                                processedCount++;
                            }
                        } catch (error) {
                            console.warn("Error processing historical data point:", dataPoint, error);
                        }
                    }
                    
                    console.log(`Successfully processed ${processedCount} new historical data points`);
                    
                    // Rebuild the chart with all data
                    const newDataArray = rebuildDataArray();
                    cc.data.datasets[0].data = newDataArray;
                    cc.update('none');
                    
                    updateDataStatus();
                    console.log("Historical data loaded and chart updated");
                    
                } catch (err) {
                    console.error("Failed to fetch historical data:", err);
                }
            }

            // Polling function
            async function pollData() {
                console.log("=== NETWORK POLLING ===", new Date().toLocaleTimeString());
                try {
                    const response = await fetch("/tempdata");
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const text = await response.text();
                    ProcessData(text);
                } catch (err) {
                    console.error("TempData request failed:", err);
                }
            }

            // Status updates
            async function updateStatus() {
                try {
                    const response = await fetch("/api/status");
                    if (!response.ok) throw new Error(`HTTP ${response.status}`); 
                        const data = await response.json();
                        ['time', 'uptime'].forEach(key => {
                            const element = document.getElementById(key);
                            if (element && data[key]) {
                                element.textContent = data[key];
                            }
                        });
                } catch (err) {
                    console.error("Status request failed:", err);
                }
            }

            // Scheduling system for label updates
            function scheduleLabelUpdate() {
                const now = new Date();
                const msUntilNextHour = (60 - now.getMinutes()) * 60000
                                      - now.getSeconds() * 1000
                                      - now.getMilliseconds();

                setTimeout(() => {
                    updateLabelsToCurrentTime();
                    scheduleLabelUpdate();
                }, msUntilNextHour);
            }

            // Initialize the application
            async function initializeApp() {
                console.log("=== INITIALIZING APPLICATION ===");
                updateLabelsToCurrentTime();
                await pollData();
                console.log("=== INITIALIZATION COMPLETE ===");
            }

            // Run initialization
            setTimeout(initializeApp, 1000);

            // Start scheduling
            scheduleLabelUpdate();

            // Tab wake-up detection
            document.addEventListener("visibilitychange", async () => {
                if (document.visibilityState === "visible") {
                    console.log("Tab became visible - polling immediately");
                    updateLabelsToCurrentTime();
                    await pollData();
                }
            });

            // Regular polling and status updates
            setInterval(pollData, 60000);
            setInterval(updateStatus, 1000);
            setInterval(updateDataStatus, 10000);
        </script>

        <script src="default.js"></script>
    </body>
</html>